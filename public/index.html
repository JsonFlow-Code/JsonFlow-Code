<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JSONFlow VM</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.6/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.34.0/min/vs/loader.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    #editor-container { height: 400px; }
    .sidebar { width: 250px; }
    .main-content { flex: 1; }
    .interaction-panel { max-height: 300px; overflow-y: auto; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // JSONFlow Schema Validator
    const validateSchema = (schema) => {
      try {
        const parsed = JSON.parse(schema);
        const errors = [];
        if (!parsed.function || typeof parsed.function !== 'string') {
          errors.push('Missing or invalid function name');
        }
        if (!parsed.schema || typeof parsed.schema !== 'object') {
          errors.push('Missing or invalid schema');
        }
        if (!Array.isArray(parsed.steps)) {
          errors.push('Steps must be an array');
        }
        for (const [index, step] of parsed.steps.entries()) {
          if (!step.type) {
            errors.push(`Step ${index}: Missing type`);
          }
          if (step.type === 'set' && (!step.target || !('value' in step))) {
            errors.push(`Step ${index}: Set step missing target or value`);
          }
        }
        return errors.length === 0 ? { valid: true, errors: [] } : { valid: false, errors };
      } catch (e) {
        return { valid: false, errors: [`Invalid JSON: ${e.message}`] };
      }
    };

    // Code Compiler
    const compileCode = (schema, language = 'python') => {
      try {
        const parsed = JSON.parse(schema);
        if (language === 'python') {
          let code = [
            '# Generated by JSONFlow VM',
            'context = {}',
            `async def ${parsed.function}():`
          ];
          for (const step of parsed.steps) {
            if (step.type === 'set') {
              code.push(`    context['${step.target}'] = ${JSON.stringify(step.value)}`);
            } else {
              code.push(`    # Unsupported step type: ${step.type}`);
            }
          }
          code.push('    return context');
          return { success: true, code: code.join('\n'), warnings: [] };
        } else if (language === 'javascript') {
          let code = [
            '// Generated by JSONFlow VM',
            'const context = {};',
            `async function ${parsed.function}() {`
          ];
          for (const step of parsed.steps) {
            if (step.type === 'set') {
              code.push(`    context['${step.target}'] = ${JSON.stringify(step.value)};`);
            } else {
              code.push(`    // Unsupported step type: ${step.type}`);
            }
          }
          code.push('    return context;');
          code.push('}');
          return { success: true, code: code.join('\n'), warnings: [] };
        } else if (language === 'solidity') {
          let code = [
            '// SPDX-License-Identifier: MIT',
            'pragma solidity ^0.8.0;',
            `contract ${parsed.function} {`,
            '    mapping(string => bytes) public context;'
          ];
          for (const step of parsed.steps) {
            if (step.type === 'set') {
              code.push(`    function set_${step.target}(bytes memory value) public {`);
              code.push(`        context["${step.target}"] = value;`);
              code.push('    }');
            }
          }
          code.push('}');
          return { success: true, code: code.join('\n'), warnings: ['Solidity support is experimental'] };
        }
        return { success: false, code: '', warnings: [`Code compilation not implemented for ${language}`] };
      } catch (e) {
        return { success: false, code: '', warnings: [`Error compiling code: ${e.message}`] };
      }
    };

    // Simulated Deployment and Execution
    class WorkflowVM {
      constructor() {
        this.context = {};
        this.functions = {};
      }

      async deploy(code, language) {
        try {
          if (language === 'python' || language === 'javascript') {
            // Create a sandboxed function
            const fn = new Function('context', `
              ${code}
              return ${language === 'python' ? 'example' : 'example'}();
            `);
            this.functions.example = async () => {
              this.context = {};
              return await fn(this.context);
            };
            return { success: true, message: 'Workflow deployed successfully' };
          }
          return { success: false, message: 'Deployment not supported for this language' };
        } catch (e) {
          return { success: false, message: `Deployment failed: ${e.message}` };
        }
      }

      async callFunction(funcName, inputs = {}) {
        try {
          if (this.functions[funcName]) {
            Object.assign(this.context, inputs);
            const result = await this.functions[funcName]();
            return { success: true, result };
          }
          return { success: false, error: `Function ${funcName} not deployed` };
        } catch (e) {
          return { success: false, error: `Execution failed: ${e.message}` };
        }
      }
    }

    const vm = new WorkflowVM();

    // Main App Component
    function App() {
      const [schema, setSchema] = useState(localStorage.getItem('jsonflow-schema') || JSON.stringify({
        function: 'example',
        schema: { inputs: {} },
        steps: [{ type: 'set', target: 'x', value: 42 }]
      }, null, 2));
      const [validation, setValidation] = useState({ valid: true, errors: [] });
      const [compiledCode, setCompiledCode] = useState({ success: false, code: '', warnings: [] });
      const [language, setLanguage] = useState('python');
      const [deployStatus, setDeployStatus] = useState(null);
      const [interactionResult, setInteractionResult] = useState(null);
      const [functionInputs, setFunctionInputs] = useState('');

      // Initialize Monaco Editor with Autocompletion
      useEffect(() => {
        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.34.0/min/vs' } });
        require(['vs/editor/editor.main'], () => {
          monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
            validate: true,
            schemas: [{
              uri: 'http://jsonflow/schema',
              fileMatch: ['*'],
              schema: {
                type: 'object',
                required: ['function', 'schema', 'steps'],
                properties: {
                  function: { type: 'string' },
                  schema: { type: 'object' },
                  steps: {
                    type: 'array',
                    items: {
                      type: 'object',
                      properties: {
                        type: { enum: ['set', 'if', 'return'] },
                        target: { type: 'string' },
                        value: {}
                      }
                    }
                  }
                }
              }
            }]
          });
          const editor = monaco.editor.create(document.getElementById('editor-container'), {
            value: schema,
            language: 'json',
            theme: 'vs-dark',
            automaticLayout: true,
            suggest: true
          });
          editor.onDidChangeModelContent(() => {
            const value = editor.getValue();
            setSchema(value);
            localStorage.setItem('jsonflow-schema', value);
            const result = validateSchema(value);
            setValidation(result);
            if (result.valid) {
              const compiled = compileCode(value, language);
              setCompiledCode(compiled);
            } else {
              setCompiledCode({ success: false, code: '', warnings: result.errors });
            }
          });
        });
      }, []);

      // Handle Language Change
      const handleLanguageChange = (e) => {
        const newLanguage = e.target.value;
        setLanguage(newLanguage);
        if (validation.valid) {
          const compiled = compileCode(schema, newLanguage);
          setCompiledCode(compiled);
        }
      };

      // Handle Deployment
      const handleDeploy = async () => {
        if (validation.valid && compiledCode.success) {
          const result = await vm.deploy(compiledCode.code, language);
          setDeployStatus(result);
          setInteractionResult(null);
        } else {
          setDeployStatus({ success: false, message: 'Cannot deploy: Invalid schema or compilation failed' });
        }
      };

      // Handle Function Interaction
      const handleCallFunction = async () => {
        try {
          const inputs = JSON.parse(functionInputs || '{}');
          const result = await vm.callFunction('example', inputs);
          setInteractionResult(result);
        } catch (e) {
          setInteractionResult({ success: false, error: `Invalid inputs: ${e.message}` });
        }
      };

      // Download Compiled Code
      const handleDownload = () => {
        if (compiledCode.success) {
          const blob = new Blob([compiledCode.code], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `workflow.${language === 'python' ? 'py' : language === 'javascript' ? 'js' : 'sol'}`;
          a.click();
          URL.revokeObjectURL(url);
        }
      };

      return (
        <div className="flex h-screen">
          <div className="sidebar bg-gray-800 text-white p-4">
            <h2 className="text-xl mb-4">JSONFlow VM</h2>
            <div className="mb-4">
              <label className="block mb-2">Target Language</label>
              <select
                value={language}
                onChange={handleLanguageChange}
                className="w-full p-2 bg-gray-700 rounded"
              >
                <option value="python">Python</option>
                <option value="javascript">JavaScript</option>
                <option value="solidity">Solidity</option>
              </select>
            </div>
            <button
              onClick={handleDeploy}
              className="w-full bg-blue-500 hover:bg-blue-600 text-white p-2 rounded mb-2"
              disabled={!validation.valid || !compiledCode.success}
            >
              Deploy Workflow
            </button>
            <button
              onClick={handleDownload}
              className="w-full bg-green-500 hover:bg-green-600 text-white p-2 rounded"
              disabled={!compiledCode.success}
            >
              Download Code
            </button>
          </div>
          <div className="main-content p-4">
            <div className="mb-4">
              <h3 className="text-lg mb-2">JSONFlow Schema Editor</h3>
              <div id="editor-container" className="border"></div>
              {validation.valid ? (
                <p className="text-green-500 mt-2">Schema is valid</p>
              ) : (
                <div className="text-red-500 mt-2">
                  {validation.errors.map((err, i) => <p key={i}>Error: {err}</p>)}
                </div>
              )}
            </div>
            <div className="mb-4">
              <h3 className="text-lg mb-2">Compiled Code</h3>
              <pre className="bg-gray-100 p-4 rounded">{compiledCode.code}</pre>
              {compiledCode.warnings.length > 0 && (
                <div className="text-yellow-500 mt-2">
                  {compiledCode.warnings.map((warn, i) => <p key={i}>Warning: {warn}</p>)}
                </div>
              )}
            </div>
            <div className="mb-4">
              <h3 className="text-lg mb-2">Deploy & Interact</h3>
              {deployStatus && (
                <p className={deployStatus.success ? 'text-green-500' : 'text-red-500'}>
                  {deployStatus.message}
                </p>
              )}
              <div className="mt-2">
                <label className="block mb-2">Function Inputs (JSON)</label>
                <textarea
                  value={functionInputs}
                  onChange={(e) => setFunctionInputs(e.target.value)}
                  className="w-full p-2 border rounded"
                  placeholder='{"key": "value"}'
                />
                <button
                  onClick={handleCallFunction}
                  className="mt-2 bg-purple-500 hover:bg-purple-600 text-white p-2 rounded"
                  disabled={!deployStatus || !deployStatus.success}
                >
                  Call Function
                </button>
              </div>
              {interactionResult && (
                <div className="mt-2 interaction-panel">
                  <h4 className="text-md mb-2">Interaction Result</h4>
                  <pre className="bg-gray-100 p-4 rounded">
                    {interactionResult.success
                      ? JSON.stringify(interactionResult.result, null, 2)
                      : `Error: ${interactionResult.error}`}
                  </pre>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Render App with createRoot
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>