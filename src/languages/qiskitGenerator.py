 from typing import Dict, Any, Optional
from engine.generator import LanguageGenerator, GeneratorError, register_generator
from engine.workflow import Workflow
from utils.logger import get_logger
from config.config import Config
import re

class QiskitGenerator(LanguageGenerator):
    """Qiskit-specific code generator for JSONFlow workflows, optimized for quantum computing."""
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger("qiskit_generator")
        self.config = Config()
        self._indent_level = self.config.get("generator.indent_level", 4)
        self._qubit_count = 0  # Track number of qubits needed
    
    def generate(self, workflow: Workflow) -> str:
        """
        Generate Qiskit code for a workflow, initializing quantum circuits and processing steps.

        Args:
            workflow: Workflow object containing function, schema, and steps.

        Returns:
            str: Generated Qiskit code (Python-based).

        Raises:
            GeneratorError: If code generation fails due to invalid workflow or step.
        """
        self.logger.info(f"Generating Qiskit code for workflow: {workflow.function}")
        
        try:
            # Reset qubit counter
            self._qubit_count = self._calculate_qubit_count(workflow)
            
            # Initialize code with imports and quantum circuit
            code = [
                "# Generated by JSONFlow QiskitGenerator",
                "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer, execute",
                "import json",
                "",
                f"def {workflow.function}():",
                "    context = {}",
                f"    qr = QuantumRegister({self._qubit_count}, 'q')",
                f"    cr = ClassicalRegister({self._qubit_count}, 'c')",
                "    circuit = QuantumCircuit(qr, cr)"
            ]
            
            # Initialize inputs with defaults or type-based fallbacks
            inputs = workflow.schema.get('inputs', {})
            for key, spec in inputs.items():
                if not isinstance(spec, dict):
                    self.logger.warning(f"Invalid input spec for {key}")
                    continue
                default = spec.get('default')
                if default is None:
                    type_map = {
                        "string": '""',
                        "integer": "0",
                        "number": "0.0",
                        "boolean": "False",
                        "object": "{}",
                        "array": "[]",
                        "null": "None"
                    }
                    default = type_map.get(spec.get('type', 'null'), 'None')
                else:
                    default = self._format_value(default, spec.get('type', 'null'))
                code.append(f"    context['{key}'] = {default}")
            
            # Generate code for each step
            for step in workflow.steps:
                code.append(self.generate_step(step, indent=1))
            
            # Simulate circuit and store results
            code.extend([
                "    # Simulate quantum circuit",
                "    simulator = Aer.get_backend('qasm_simulator')",
                "    job = execute(circuit, simulator, shots=1024)",
                "    result = job.result()",
                "    counts = result.get_counts(circuit)",
                "    context['quantum_counts'] = counts",
                "    return context",
                "",
                "if __name__ == '__main__':",
                f"    result = {workflow.function}()",
                "    print(json.dumps(result, indent=2))"
            ])
            
            return "\n".join(filter(None, code))  # Remove empty lines
        
        except Exception as e:
            self.logger.error(f"Qiskit code generation failed: {str(e)}")
            raise GeneratorError(f"Qiskit code generation failed: {str(e)}")
    
    def generate_blockchain_operation(self, step: Dict[str, Any], indent: int) -> str:
        """
        Generate Qiskit code for a blockchain_operation step (simulated).

        Supports Ethereum transfers; other chains/actions return comments.
        """
        chain = step.get('chain')
        action = step.get('action')
        params = step.get('params', {})
        target = step.get('target')
        
        if chain == "ethereum" and action == "transfer":
            to_address = params.get('to')
            value = params.get('value')
            if not to_address or not re.match(r'^0x[a-fA-F0-9]{40}$', to_address):
                raise GeneratorError(f"Invalid Ethereum address: {to_address}")
            if not value or not isinstance(value, (int, str, float)):
                raise GeneratorError(f"Invalid value for transfer: {value}")
            sender = 'context.get("sender", "0x0000000000000000000000000000000000000000")'
            indent_str = " " * (indent * self._indent_level)
            return f"{indent_str}context['{target}'] = simulate_transfer('{to_address}', {value}, {sender})  # Simulated transfer"
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}# Unsupported blockchain operation: {chain} {action}"
    
    def generate_if(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for an if step with safe context access."""
        condition = self._safe_format_expr(step['condition'])
        indent_str = " " * (indent * self._indent_level)
        then_code = "\n".join(self.generate_step(s, indent + 1) for s in step['then'])
        else_code = "\n".join(self.generate_step(s, indent + 1) for s in step.get('else', []))
        code = [f"{indent_str}if {condition}:"]
        code.append(then_code)
        if else_code:
            code.append(f"{indent_str}else:")
            code.append(else_code)
        return "\n".join(code)
    
    def generate_set(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a set step, storing in context."""
        target = step.get('target')
        if not isinstance(target, str) or not target:
            raise GeneratorError("Invalid or missing target in set step")
        value = self._safe_format_expr(step['value'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}context['{target}'] = {value}"
    
    def generate_return(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a return step."""
        value = self._safe_format_expr(step['value'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}return {value}"
    
    def generate_try(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a try step with error handling."""
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        catch = step.get('catch', {})
        catch_code = "\n".join(self.generate_step(s, indent + 1) for s in catch.get('body', [])) if catch else ""
        indent_str = " " * (indent * self._indent_level)
        code = [f"{indent_str}try:"]
        code.append(body_code)
        if catch_code:
            error_var = catch.get('error_var', 'e')
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', error_var):
                raise GeneratorError(f"Invalid error variable name: {error_var}")
            code.append(f"{indent_str}except Exception as {error_var}:")
            code.append(f"{indent_str}    context['{error_var}'] = str({error_var})")
            code.append(catch_code)
        return "\n".join(code)
    
    def generate_while(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a while step."""
        condition = self._safe_format_expr(step['condition'])
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}while {condition}:\n{body_code}"
    
    def generate_foreach(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a foreach step."""
        collection = self._safe_format_expr(step['collection'])
        iterator = step['iterator']
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', iterator):
            raise GeneratorError(f"Invalid iterator name: {iterator}")
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}for {iterator} in {collection}:\n{indent_str}    context['{iterator}'] = {iterator}\n{body_code}"
    
    def generate_assert(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for an assert step."""
        condition = self._safe_format_expr(step['condition'])
        message = step.get('message', 'Assertion failed')
        if not isinstance(message, str):
            raise GeneratorError("Assert message must be a string")
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}assert {condition}, '{message}'"
    
    def generate_ai_infer(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for an ai_infer step (simulated)."""
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        if not model or not target:
            raise GeneratorError("Missing model or target in ai_infer step")
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}context['{target}'] = simulate_ai_infer('{model}', {input_data})  # Simulated AI inference"
    
    def generate_call_workflow(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a call_workflow step (simulated)."""
        workflow_id = step.get('workflow')
        target = step.get('target')
        if not workflow_id or not target:
            raise GeneratorError("Missing workflow or target in call_workflow step")
        args = ", ".join(f"'{k}': {self._safe_format_expr(v)}" for k, v in step.get('args', {}).items())
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}context['{target}'] = simulate_workflow('{workflow_id}', {{{args}}})  # Simulated workflow call"
    
    def generate_quantum_operation(self, step: Dict[str, Any], indent: int) -> str:
        """Generate Qiskit code for a quantum_operation step."""
        operation = step.get('operation')
        qubits = step.get('qubits')
        target = step.get('target')
        if not operation or not qubits or not target:
            raise GeneratorError("Missing operation, qubits, or target in quantum_operation step")
        if not isinstance(qubits, list) or not all(isinstance(q, int) for q in qubits):
            raise GeneratorError("Qubits must be a list of integers")
        if max(qubits) >= self._qubit_count:
            raise GeneratorError(f"Qubit index {max(qubits)} exceeds allocated qubits {self._qubit_count}")
        
        indent_str = " " * (indent * self._indent_level)
        gate_map = {
            "h": f"circuit.h(qr[{qubits[0]}])",
            "x": f"circuit.x(qr[{qubits[0]}])",
            "y": f"circuit.y(qr[{qubits[0]}])",
            "z": f"circuit.z(qr[{qubits[0]}])",
            "cx": f"circuit.cx(qr[{qubits[0]}], qr[{qubits[1]}])",
            "measure": f"circuit.measure(qr[{qubits[0]}], cr[{qubits[0]}])"
        }
        
        if operation not in gate_map:
            raise GeneratorError(f"Unsupported quantum operation: {operation}")
        
        if operation == "cx" and len(qubits) != 2:
            raise GeneratorError("CNOT gate requires exactly two qubits")
        if operation != "cx" and operation != "measure" and len(qubits) != 1:
            raise GeneratorError(f"{operation.upper()} gate requires exactly one qubit")
        
        return f"{indent_str}{gate_map[operation]}  # Store result in context['{target}'] via simulation"
    
    def _safe_format_expr(self, expr: Any) -> str:
        """
        Format an expression safely, converting context access to safe dictionary access.

        Args:
            expr: Expression object or value from schema.

        Returns:
            str: Python-compatible expression string for Qiskit.
        """
        formatted = self._format_expr(expr)
        # Convert context.get("key") to context.get("key", None)
        formatted = re.sub(
            r"context\.get\(['\"](.*?)['\"]\)",
            r"context.get('\1', None)",
            formatted
        )
        return formatted
    
    def _format_value(self, value: Any, json_type: str) -> str:
        """Format a value for Python/Qiskit initialization."""
        if json_type == "string":
            return f"'{value}'" if isinstance(value, str) else "''"
        elif json_type == "integer":
            return str(value) if isinstance(value, int) else "0"
        elif json_type == "number":
            return str(value) if isinstance(value, (int, float)) else "0.0"
        elif json_type == "boolean":
            return "True" if value else "False"
        elif json_type == "object":
            return "{}"
        elif json_type == "array":
            return "[]"
        return "None"
    
    def _calculate_qubit_count(self, workflow: Workflow) -> int:
        """Calculate the number of qubits needed based on quantum_operation steps."""
        max_qubit = 0
        for step in workflow.steps:
            if step.get('type') == 'quantum_operation':
                qubits = step.get('qubits', [])
                if qubits and isinstance(qubits, list):
                    max_qubit = max(max_qubit, max(qubits, default=-1) + 1)
        return max(max_qubit, 1)  # Ensure at least one qubit
    
    def _indent_code(self, code: str, indent: int) -> str:
        """Indent code with configured indent level."""
        indent_str = " " * (indent * self._indent_level)
        return "\n".join(indent_str + line for line in code.split("\n") if line.strip())

# Register the generator
register_generator('qiskit', QiskitGenerator)