from typing import Dict, Any, Optional
from engine.generator import LanguageGenerator, GeneratorError, register_generator
from engine.workflow import Workflow
from utils.logger import get_logger
from config.config import Config
import re
import uuid

class ReactGenerator(LanguageGenerator):
    """React/TypeScript-specific code generator for JSONFlow workflows, producing a UI-driven application."""
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger("react_generator")
        self.config = Config()
        self._indent_level = self.config.get("generator.indent_level", 4)
    
    def generate(self, workflow: Workflow) -> str:
        """
        Generate a React/TypeScript single-page application for a workflow, rendering an interactive UI.

        Args:
            workflow: Workflow object containing function, schema, and steps.

        Returns:
            str: Generated React/TypeScript code wrapped in HTML.

        Raises:
            GeneratorError: If code generation fails due to invalid workflow or step.
        """
        self.logger.info(f"Generating React/TypeScript code for workflow: {workflow.function}")
        
        try:
            # Initialize code with HTML structure and CDN imports
            code = [
                "<!DOCTYPE html>",
                "<html lang='en'>",
                "<head>",
                "    <meta charset='UTF-8'>",
                "    <meta name='viewport' content='width=device-width, initial-scale=1.0'>",
                f"    <title>{workflow.function} Workflow</title>",
                "    <script src='https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js'></script>",
                "    <script src='https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js'></script>",
                "    <script src='https://cdn.jsdelivr.net/npm/@babel/standalone@7/babel.min.js'></script>",
                "    <script src='https://cdn.tailwindcss.com'></script>",
                "</head>",
                "<body>",
                "    <div id='root'></div>",
                "    <script type='text/babel' data-type='module'>",
                "",
                "// Generated by JSONFlow ReactGenerator",
                "import * as React from 'react';",
                "import { useState, useEffect } from 'react';",
                "import { createRoot } from 'react-dom/client';",
                "",
                "interface Context { [key: string]: any; }",
                f"// Workflow: {workflow.function}",
                "const WorkflowApp: React.FC = () => {",
                "    const [context, setContext] = useState<Context>({});",
                "    const [stepIndex, setStepIndex] = useState<number>(0);",
                "    const [error, setError] = useState<string | null>(null);",
                "",
                "    // Initialize inputs",
                "    useEffect(() => {",
                "        const initialContext: Context = {};"
            ]
            
            # Initialize inputs with defaults or type-based fallbacks
            inputs = workflow.schema.get('inputs', {})
            for key, spec in inputs.items():
                if not isinstance(spec, dict):
                    self.logger.warning(f"Invalid input spec for {key}")
                    continue
                default = spec.get('default')
                if default is None:
                    type_map = {
                        "string": "''",
                        "integer": "0",
                        "number": "0.0",
                        "boolean": "false",
                        "object": "{}",
                        "array": "[]",
                        "null": "null"
                    }
                    default = type_map.get(spec.get('type', 'null'), 'null')
                else:
                    default = self._format_value(default, spec.get('type', 'null'))
                code.append(f"        initialContext['{key}'] = {default};")
            
            code.extend([
                "        setContext(initialContext);",
                "    }, []);",
                "",
                "    // Execute steps",
                "    const executeStep = async () => {",
                "        if (stepIndex >= steps.length) return;",
                "        try {",
                "            const step = steps[stepIndex];",
                "            const newContext = { ...context };",
                "            let nextIndex = stepIndex + 1;"
            ])
            
            # Generate step execution logic
            code.append("            switch (step.type) {")
            for i, step in enumerate(workflow.steps):
                step_code = self.generate_step(step, indent=4)
                code.append(f"                case {i}:")
                code.append(step_code)
                code.append("                    break;")
            code.extend([
                "                default:",
                "                    setError('Unknown step type');",
                "                    return;",
                "            }",
                "            setContext(newContext);",
                "            setStepIndex(nextIndex);",
                "        } catch (err: any) {",
                "            setError(err.message);",
                "        }",
                "    };",
                "",
                "    // Steps array",
                f"    const steps = {self._format_steps(workflow.steps)};",
                "",
                "    // Run next step on click",
                "    const handleNext = () => {",
                "        executeStep();",
                "    };",
                "",
                "    // Render UI",
                "    return (",
                "        <div className='min-h-screen bg-gray-100 flex items-center justify-center'>",
                "            <div className='bg-white p-6 rounded-lg shadow-lg w-full max-w-md'>",
                f"                <h1 className='text-2xl font-bold mb-4'>{workflow.function} Workflow</h1>",
                "                {error && <div className='text-red-500 mb-4'>{error}</div>}",
                "                <div className='mb-4'>",
                "                    <h2 className='text-lg font-semibold'>Context</h2>",
                "                    <pre className='bg-gray-200 p-2 rounded'>",
                "                        {JSON.stringify(context, null, 2)}",
                "                    </pre>",
                "                </div>",
                "                <div className='mb-4'>",
                "                    <h2 className='text-lg font-semibold'>Current Step</h2>",
                "                    <p>{stepIndex < steps.length ? steps[stepIndex].type : 'Completed'}</p>",
                "                </div>",
                "                <button",
                "                    onClick={handleNext}",
                "                    disabled={stepIndex >= steps.length}",
                "                    className='bg-blue-500 text-white px-4 py-2 rounded disabled:bg-gray-400'",
                "                >",
                "                    Next Step",
                "                </button>",
                "            </div>",
                "        </div>",
                "    );",
                "};",
                "",
                "const root = createRoot(document.getElementById('root')!);",
                "root.render(<WorkflowApp />);",
                "    </script>",
                "</body>",
                "</html>"
            ])
            
            return "\n".join(filter(None, code))  # Remove empty lines
        
        except Exception as e:
            self.logger.error(f"React code generation failed: {str(e)}")
            raise GeneratorError(f"React code generation failed: {str(e)}")
    
    def generate_blockchain_operation(self, step: Dict[str, Any], indent: int) -> str:
        """
        Generate React/TypeScript code for a blockchain_operation step.

        Supports Ethereum transfers; other chains/actions return comments.
        """
        chain = step.get('chain')
        action = step.get('action')
        params = step.get('params', {})
        target = step.get('target')
        
        if chain == "ethereum" and action == "transfer":
            to_address = params.get('to')
            value = params.get('value')
            if not to_address or not re.match(r'^0x[a-fA-F0-9]{40}$', to_address):
                raise GeneratorError(f"Invalid Ethereum address: {to_address}")
            if not value or not isinstance(value, (int, str, float)):
                raise GeneratorError(f"Invalid value for transfer: {value}")
            sender = "context['sender'] ?? '0x0000000000000000000000000000000000000000'"
            indent_str = " " * (indent * self._indent_level)
            return "\n".join([
                f"{indent_str}const web3 = new Web3();",
                f"{indent_str}newContext['{target}'] = await web3.eth.sendTransaction({{",
                f"{indent_str}    from: {sender},",
                f"{indent_str}    to: '{to_address}',",
                f"{indent_str}    value: {value}",
                f"{indent_str}}});"
            ])
        return f"{' ' * (indent * self._indent_level)}// Unsupported blockchain operation: {chain} {action}"
    
    def generate_if(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for an if step with safe context access."""
        condition = self._safe_format_expr(step['condition'])
        indent_str = " " * (indent * self._indent_level)
        then_code = "\n".join(self.generate_step(s, indent + 1) for s in step['then'])
        else_code = "\n".join(self.generate_step(s, indent + 1) for s in step.get('else', []))
        code = [f"{indent_str}if ({condition}) {{", then_code, f"{indent_str}}}"]
        if else_code:
            code.append(f"{indent_str}else {{")
            code.append(else_code)
            code.append(f"{indent_str}}}")
        return "\n".join(code)
    
    def generate_set(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a set step, updating context."""
        target = step.get('target')
        if not isinstance(target, str) or not target:
            raise GeneratorError("Invalid or missing target in set step")
        value = self._safe_format_expr(step['value'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}newContext['{target}'] = {value};"
    
    def generate_return(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a return step."""
        value = self._safe_format_expr(step['value'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}return {value};"
    
    def generate_try(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a try step with error handling."""
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        catch = step.get('catch', {})
        catch_code = "\n".join(self.generate_step(s, indent + 1) for s in catch.get('body', [])) if catch else ""
        finally_code = "\n".join(self.generate_step(s, indent + 1) for s in step.get('finally', []))
        indent_str = " " * (indent * self._indent_level)
        code = [f"{indent_str}try {{", body_code, f"{indent_str}}}"]
        if catch_code:
            error_var = catch.get('error_var', 'error')
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', error_var):
                raise GeneratorError(f"Invalid error variable name: {error_var}")
            code.append(f"{indent_str}catch ({error_var}: any) {{")
            code.append(f"{indent_str}    newContext['{error_var}'] = {error_var}.message;")
            code.append(catch_code)
            code.append(f"{indent_str}}}")
        if finally_code:
            code.append(f"{indent_str}finally {{")
            code.append(finally_code)
            code.append(f"{indent_str}}}")
        return "\n".join(code)
    
    def generate_while(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a while step."""
        condition = self._safe_format_expr(step['condition'])
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}while ({condition}) {{\n{body_code}\n{indent_str}}}"
    
    def generate_foreach(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a foreach step."""
        collection = self._safe_format_expr(step['collection'])
        iterator = step['iterator']
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', iterator):
            raise GeneratorError(f"Invalid iterator name: {iterator}")
        body_code = "\n".join(self.generate_step(s, indent + 1) for s in step['body'])
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}for (const {iterator} of {collection}) {{\n{indent_str}    newContext['{iterator}'] = {iterator};\n{body_code}\n{indent_str}}}"
    
    def generate_assert(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for an assert step."""
        condition = self._safe_format_expr(step['condition'])
        message = step.get('message', 'Assertion failed')
        if not isinstance(message, str):
            raise GeneratorError("Assert message must be a string")
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}if (!({condition})) {{ throw new Error('{message}'); }}"
    
    def generate_ai_infer(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for an ai_infer step (simulated)."""
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        if not model or not target:
            raise GeneratorError("Missing model or target in ai_infer step")
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}newContext['{target}'] = await simulateAiInfer('{model}', {input_data}); // Simulated AI inference"
    
    def generate_call_workflow(self, step: Dict[str, Any], indent: int) -> str:
        """Generate React/TypeScript code for a call_workflow step (simulated)."""
        workflow_id = step.get('workflow')
        target = step.get('target')
        if not workflow_id or not target:
            raise GeneratorError("Missing workflow or target in call_workflow step")
        args = ", ".join(f"{k}: {self._safe_format_expr(v)}" for k, v in step.get('args', {}).items())
        indent_str = " " * (indent * self._indent_level)
        return f"{indent_str}newContext['{target}'] = await simulateWorkflow('{workflow_id}', {{ {args} }}); // Simulated workflow call"
    
    def _safe_format_expr(self, expr: Any) -> str:
        """
        Format an expression safely, converting context access to safe property access.

        Args:
            expr: Expression object or value from schema.

        Returns:
            str: React/TypeScript-compatible expression string.
        """
        formatted = self._format_expr(expr)
        # Convert context.get("key") to context[key] ?? null
        formatted = re.sub(
            r"context\.get\(['\"](.*?)['\"]\)",
            r"context[\1] ?? null",
            formatted
        )
        return formatted
    
    def _format_value(self, value: Any, json_type: str) -> str:
        """Format a value for React/TypeScript initialization."""
        if json_type == "string":
            return f"'{value}'" if isinstance(value, str) else "''"
        elif json_type == "integer":
            return str(value) if isinstance(value, int) else "0"
        elif json_type == "number":
            return str(value) if isinstance(value, (int, float)) else "0.0"
        elif json_type == "boolean":
            return str(value).lower() if isinstance(value, bool) else "false"
        elif json_type == "object":
            return "{}"
        elif json_type == "array":
            return "[]"
        return "null"
    
    def _format_steps(self, steps: list) -> str:
        """Format steps as a JSON string for the steps array."""
        import json
        return json.dumps(steps, ensure_ascii=False)
    
    def _indent_code(self, code: str, indent: int) -> str:
        """Indent code with configured indent level."""
        indent_str = " " * (indent * self._indent_level)
        return "\n".join(indent_str + line for line in code.split("\n") if line.strip())

# Register the generator
register_generator('react', ReactGenerator)