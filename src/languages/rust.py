import json
import re
from typing import Dict, Any
from engine.generator import LanguageGenerator
from engine.workflow import Workflow
from utils.logger import get_logger
from config.config import Config

class RustGenerator(LanguageGenerator):
    def __init__(self):
        super().__init__()
        self.logger = get_logger("rust_generator")
        self.config = Config()
        self._indent_level = self.config.get("generator.indent_level", 4)
        self._expr_cache = {}

    def generate(self, workflow: Workflow) -> str:
        self.logger.info(f"Generating Rust code for workflow: {workflow.function}")
        self._expr_cache.clear()
        try:
            code = [
                "// Generated by JSONFlow RustGenerator",
                "use std::collections::HashMap;",
                "use regex::Regex;",
                "use web3; // Simulated web3 for blockchain operations",
                "use solana; // Simulated Solana SDK",
                "use quantum; // Simulated quantum library",
                "",
                f"// Workflow: {workflow.function}",
                f"// Description: {workflow.metadata.get('description', 'N/A')}",
                f"// Schema Version: {workflow.metadata.get('schema_version', '1.1.0')}",
                "pub struct Workflow {",
                "    context: HashMap<String, String>,",
                "}",
                "",
                "impl Workflow {",
                "    pub fn new() -> Self {",
                "        Workflow { context: HashMap::new() }",
                "    }",
                "",
                f"    pub fn {workflow.function}(&mut self) -> Result<String, String> {{"
            ]
            inputs = workflow.schema.get('inputs', {})
            for key, spec in inputs.items():
                if not isinstance(spec, dict) or 'type' not in spec:
                    self.logger.warning(f"Invalid input spec for {key}")
                    continue
                default = spec.get('default')
                constraints = spec.get('constraints', {})
                type_map = {
                    "string": "\"\"",
                    "integer": "\"0\"",
                    "number": "\"0.0\"",
                    "boolean": "\"false\"",
                    "object": "\"{}\"",
                    "array": "\"[]\"",
                    "null": "\"null\""
                }
                if default is None:
                    default = type_map.get(spec.get('type', 'null'), "\"null\"")
                else:
                    if 'minLength' in constraints and isinstance(default, str) and len(default) < constraints['minLength']:
                        raise ValueError(f"Default value for {key} violates minLength")
                    if 'pattern' in constraints and isinstance(default, str) and not re.match(constraints['pattern'], default):
                        raise ValueError(f"Default value for {key} violates pattern")
                    if 'enum' in constraints and default not in constraints['enum']:
                        raise ValueError(f"Default value for {key} not in enum")
                    default = json.dumps(default)
                code.append(f"        self.context.insert(\"{key}\".to_string(), {default}.to_string());")
                if spec.get('ui'):
                    code.append(f"        // UI for {key}: {json.dumps(spec['ui'])}")
            for invariant in workflow.get('invariants', []):
                condition = self._safe_format_expr(invariant['condition'])
                message = invariant.get('message', 'Invariant failed')
                code.append(f"        if !({condition}) {{")
                code.append(f"            return Err(\"{message}\".to_string());")
                code.append("        }")
            for step in workflow.steps:
                self.logger.debug(f"Generating code for step: {step.get('type')}")
                code.append(self.generate_step(step, indent=2))
            code.append("        Ok(self.context.get(\"result\").cloned().unwrap_or_default())")
            code.append("    }")
            code.extend([
                "",
                "    fn simulate_ai_infer(&self, model: &str, input: &str) -> String {",
                "        \"simulated\".to_string()",
                "    }",
                "    fn simulate_workflow(&self, id: &str, args: &str) -> String {",
                "        \"simulated\".to_string()",
                "    }",
                "    fn simulate_crypto_sign(&self, algorithm: &str, data: &str, key: &str) -> String {",
                "        \"simulated_signature\".to_string()",
                "    }",
                "    fn simulate_crypto_verify(&self, algorithm: &str, data: &str, signature: &str, key: &str) -> bool {",
                "        true",
                "    }",
                "    fn simulate_quantum_algorithm(&self, algorithm: &str, params: &str) -> String {",
                "        \"simulated\".to_string()",
                "    }",
                "}",
            ])
            return "\n".join(filter(None, code))
        except Exception as e:
            self.logger.error(f"Rust code generation failed: {str(e)}")
            raise ValueError(f"Rust code generation failed: {str(e)}")

    def generate_step(self, step: Dict[str, Any], indent: int) -> str:
        step_type = step.get('type')
        handlers = {
            'set': self.generate_set,
            'if': self.generate_if,
            'return': self.generate_return,
            'try': self.generate_try,
            'while': self.generate_while,
            'foreach': self.generate_foreach,
            'parallel': self.generate_parallel,
            'assert': self.generate_assert,
            'event': self.generate_event,
            'require_role': self.generate_require_role,
            'ai_infer': self.generate_ai_infer,
            'ai_train': self.generate_ai_train,
            'ai_classify': self.generate_ai_classify,
            'ai_embed': self.generate_ai_embed,
            'ai_explain': self.generate_ai_explain,
            'quantum_circuit': self.generate_quantum_circuit,
            'quantum_measure': self.generate_quantum_measure,
            'quantum_algorithm': self.generate_quantum_algorithm,
            'blockchain_operation': self.generate_blockchain_operation,
            'crypto_sign': self.generate_crypto_sign,
            'crypto_verify': self.generate_crypto_verify,
            'regex_match': self.generate_regex_match,
            'audit_log': self.generate_audit_log,
            'call_workflow': self.generate_call_workflow
        }
        handler = handlers.get(step_type)
        if handler:
            code = handler(step)
        elif step_type.startswith('custom_'):
            code = self.generate_custom(step)
        else:
            code = f"        // Unsupported step type: {step_type}"
        if step.get('ui'):
            code = f"{code}\n        // UI: {json.dumps(step['ui'])}"
        return self._indent_code(code, indent)

    def generate_set(self, step: Dict[str, Any]) -> str:
        target = step.get('target')
        if not isinstance(target, str) or not target:
            raise ValueError("Invalid or missing target in set step")
        value = self._safe_format_expr(step['value'])
        return f"self.context.insert(\"{target}\".to_string(), {value}.to_string());"

    def generate_if(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        then_code = "\n".join(self.generate_step(s, indent=3) for s in step['then'])
        else_code = "\n".join(self.generate_step(s, indent=3) for s in step.get('else', []))
        code = [f"if {condition} {{", then_code, "        }}"]
        if else_code:
            code.append("        else {")
            code.append(else_code)
            code.append("        }")
        return "\n".join(code)

    def generate_return(self, step: Dict[str, Any]) -> str:
        value = self._safe_format_expr(step['value'])
        return f"self.context.insert(\"result\".to_string(), {value}.to_string()); return Ok(self.context.get(\"result\").cloned().unwrap_or_default());"

    def generate_try(self, step: Dict[str, Any]) -> str:
        body_code = "\n".join(self.generate_step(s, indent=3) for s in step['body'])
        catch = step.get('catch', {})
        catch_code = "\n".join(self.generate_step(s, indent=3) for s in catch.get('body', [])) if catch else ""
        finally_code = "\n".join(self.generate_step(s, indent=3) for s in step.get('finally', []))
        code = ["{ // Simulated try block", body_code]
        if catch_code:
            error_var = catch.get('error_var', 'error')
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', error_var):
                raise ValueError(f"Invalid error variable name: {error_var}")
            code.append(f"        // Simulated catch for {error_var}")
            code.append(f"        self.context.insert(\"{error_var}\".to_string(), \"error\".to_string());")
            code.append(catch_code)
        if finally_code:
            code.append("        // Simulated finally")
            code.append(finally_code)
        code.append("        }")
        return "\n".join(code)

    def generate_while(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        body_code = "\n".join(self.generate_step(s, indent=3) for s in step['body'])
        return f"while {condition} {{\n{body_code}\n        }}"

    def generate_foreach(self, step: Dict[str, Any]) -> str:
        collection = self._safe_format_expr(step['collection'])
        iterator = step['iterator']
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', iterator):
            raise ValueError(f"Invalid iterator name: {iterator}")
        body_code = "\n".join(self.generate_step(s, indent=3) for s in step['body'])
        return f"for {iterator} in {collection} {{\n    self.context.insert(\"{iterator}\".to_string(), {iterator}.to_string());\n{body_code}\n        }}"

    def generate_parallel(self, step: Dict[str, Any]) -> str:
        branches = step.get('branches', [])
        branch_codes = [
            "\n".join(self.generate_step(s, indent=3) for s in branch)
            for branch in branches
        ]
        return "\n".join([f"// Simulated parallel branch {i}\n{code}" for i, code in enumerate(branch_codes)])

    def generate_assert(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        message = step.get('message', 'Assertion failed')
        if not isinstance(message, str):
            raise ValueError("Assert message must be a string")
        return f"if !({condition}) {{ return Err(\"{message}\".to_string()); }}"

    def generate_event(self, step: Dict[str, Any]) -> str:
        name = step.get('name')
        params = step.get('params', {})
        params_str = ", ".join(f"{k}: {self._safe_format_expr(v)}" for k, v in params.items())
        return f"println!(\"Event: {name} {{ {params_str} }}\");"

    def generate_require_role(self, step: Dict[str, Any]) -> str:
        role = step.get('role')
        return f"if !self.context.get(\"user_roles\").map_or(false, |r| r.contains(\"{role}\")) {{ return Err(\"Missing role: {role}\".to_string()); }}"

    def generate_ai_infer(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        if not model or not target:
            raise ValueError("Missing model or target in ai_infer step")
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_ai_infer(\"{model}\", {input_data}).to_string());"

    def generate_ai_train(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        data = self._safe_format_expr(step['data'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_ai_train(\"{model}\", {data}).to_string());"

    def generate_ai_classify(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_ai_classify(\"{model}\", {input_data}).to_string());"

    def generate_ai_embed(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_ai_embed(\"{model}\", {input_data}).to_string());"

    def generate_ai_explain(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_ai_explain(\"{model}\", {input_data}).to_string());"

    def generate_quantum_circuit(self, step: Dict[str, Any]) -> str:
        gates = step.get('gates', [])
        qubits = step.get('qubits')
        target = step.get('target')
        if not gates or not qubits or not target:
            raise ValueError("Missing gates, qubits, or target in quantum_circuit step")
        gate_code = []
        for gate in gates:
            gate_type = gate.get('gate')
            target_qubit = gate.get('target')
            control = gate.get('control')
            params = gate.get('parameters', {})
            if gate_type in ['H', 'X', 'Y', 'Z', 'T', 'S']:
                gate_code.append(f"circuit.{gate_type.lower()}({target_qubit});")
            elif gate_type == 'CNOT':
                if control is None:
                    raise ValueError("Missing control qubit for CNOT gate")
                gate_code.append(f"circuit.cnot({control}, {target_qubit});")
            elif gate_type in ['RX', 'RY', 'RZ']:
                angle = params.get('angle')
                if angle is None:
                    raise ValueError(f"Missing angle for {gate_type} gate")
                gate_code.append(f"circuit.{gate_type.lower()}({target_qubit}, {angle});")
        return "\n".join([
            f"let mut circuit = quantum::QuantumCircuit::new({qubits});",
            *gate_code,
            f"self.context.insert(\"{target}\".to_string(), \"simulated_circuit\".to_string());"
        ])

    def generate_quantum_measure(self, step: Dict[str, Any]) -> str:
        circuit = self._safe_format_expr(step['circuit'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), {circuit}.to_string());"

    def generate_quantum_algorithm(self, step: Dict[str, Any]) -> str:
        algorithm = step.get('algorithm')
        params = json.dumps(step.get('parameters', {}))
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_quantum_algorithm(\"{algorithm}\", \"{params}\").to_string());"

    def generate_blockchain_operation(self, step: Dict[str, Any]) -> str:
        chain = step.get('chain')
        action = step.get('action')
        params = step.get('params', {})
        target = step.get('target')
        if chain == "ethereum" and action == "transfer":
            to_address = params.get('to')
            value = params.get('value')
            if not to_address or not re.match(r'^0x[a-fA-F0-9]{40}$', to_address):
                raise ValueError(f"Invalid Ethereum address: {to_address}")
            if not value or not isinstance(value, (int, str, float)):
                raise ValueError(f"Invalid value for transfer: {value}")
            return f"self.context.insert(\"{target}\".to_string(), web3::eth::send_transaction(\"{to_address}\", {value}).to_string());"
        elif chain == "solana" and action == "transfer":
            to_address = params.get('to')
            lamports = params.get('value')
            if not to_address or not re.match(r'^[1-9A-HJ-NP-Za-km-z]{32,44}$', to_address):
                raise ValueError(f"Invalid Solana address: {to_address}")
            return f"self.context.insert(\"{target}\".to_string(), solana::transfer(\"{to_address}\", {lamports}).to_string());"
        return f"// Unsupported blockchain operation: {chain} {action}"

    def generate_crypto_sign(self, step: Dict[str, Any]) -> str:
        algorithm = step.get('algorithm')
        data = self._safe_format_expr(step['data'])
        key = self._safe_format_expr(step['key'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_crypto_sign(\"{algorithm}\", {data}, {key}).to_string());"

    def generate_crypto_verify(self, step: Dict[str, Any]) -> str:
        algorithm = step.get('algorithm')
        data = self._safe_format_expr(step['data'])
        signature = self._safe_format_expr(step['signature'])
        key = self._safe_format_expr(step['key'])
        target = step.get('target')
        return f"self.context.insert(\"{target}\".to_string(), if self.simulate_crypto_verify(\"{algorithm}\", {data}, {signature}, {key}) {{ \"true\".to_string() }} else {{ \"false\".to_string() }});"

    def generate_regex_match(self, step: Dict[str, Any]) -> str:
        pattern = step.get('pattern')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        try:
            re.compile(pattern)
        except re.error:
            raise ValueError(f"Invalid regex pattern: {pattern}")
        return f"self.context.insert(\"{target}\".to_string(), if Regex::new(\"{pattern}\").unwrap().is_match({input_data}) {{ \"true\".to_string() }} else {{ \"false\".to_string() }});"

    def generate_audit_log(self, step: Dict[str, Any]) -> str:
        message = step.get('message')
        metadata = json.dumps(step.get('metadata', {}))
        return f"println!(\"Audit: {message} {metadata}\");"

    def generate_call_workflow(self, step: Dict[str, Any]) -> str:
        workflow_id = step.get('workflow')
        target = step.get('target')
        args = json.dumps(step.get('args', {}))
        return f"self.context.insert(\"{target}\".to_string(), self.simulate_workflow(\"{workflow_id}\", \"{args}\").to_string());"

    def generate_custom(self, step: Dict[str, Any]) -> str:
        custom_type = step.get('type')
        props = step.get('custom_properties', {})
        return f"// Custom step: {custom_type} with properties {json.dumps(props)}"

    def _safe_format_expr(self, expr: Any) -> str:
        expr_key = json.dumps(expr)
        if expr_key in self._expr_cache:
            return self._expr_cache[expr_key]
        formatted = self._format_expr(expr)
        formatted = re.sub(r"self\.context\.get\(['\"](.*?)['\"]\)", r"self.context.get('\1').unwrap_or(&String::new())", formatted)
        self._expr_cache[expr_key] = formatted
        return formatted

    def _format_expr(self, expr: Any) -> str:
        if not isinstance(expr, dict):
            return f"{json.dumps(expr)}.to_string()"
        if 'get' in expr:
            return f"self.context.get(\"{expr['get']}\").unwrap_or(&String::new())"
        if 'value' in expr:
            return f"{json.dumps(expr['value'])}.to_string()"
        if 'add' in expr:
            return f"({'+'.join(self._format_expr(e) for e in expr['add'])}).to_string()"
        if 'subtract' in expr:
            return f"({'-'.join(self._format_expr(e) for e in expr['subtract'])}).to_string()"
        if 'multiply' in expr:
            return f"({'*'.join(self._format_expr(e) for e in expr['multiply'])}).to_string()"
        if 'divide' in expr:
            return f"({'/'.join(self._format_expr(e) for e in expr['divide'])}).to_string()"
        if 'compare' in expr:
            op_map = {'===': '==', '!==': '!='}
            op = op_map.get(expr['compare']['op'], expr['compare']['op'])
            return f"({self._format_expr(expr['compare']['left'])} {op} {self._format_expr(expr['compare']['right'])})"
        if 'not' in expr:
            return f"!({self._format_expr(expr['not'])})"
        if 'and' in expr:
            return f"({' && '.join(self._format_expr(e) for e in expr['and'])})"
        if 'or' in expr:
            return f"({' || '.join(self._format_expr(e) for e in expr['or'])})"
        if 'concat' in expr:
            return f"[{','.join(self._format_expr(e) for e in expr['concat'])}].join(\"\")"
        if 'hash' in expr:
            return f"hash(\"{expr['hash']['algorithm']}\", {self._format_expr(expr['hash']['input'])}).to_string()"
        if 'regex' in expr:
            return f"Regex::new(\"{expr['regex']['pattern']}\").unwrap().is_match({self._format_expr(expr['regex']['input'])}).to_string()"
        raise ValueError(f"Unsupported expression: {expr}")

    def _indent_code(self, code: str, indent: int) -> str:
        indent_str = " " * (indent * self._indent_level)
        return "\n".join(indent_str + line for line in code.split("\n") if line.strip())

def register_rust_generator():
    from engine.generator import register_generator
    register_generator('rust', RustGenerator)