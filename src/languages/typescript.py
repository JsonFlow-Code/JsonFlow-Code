import json
import re
from typing import Dict, Any
from engine.generator import LanguageGenerator
from engine.workflow import Workflow
from utils.logger import get_logger
from config.config import Config

class TypeScriptGenerator(LanguageGenerator):
    def __init__(self):
        super().__init__()
        self.logger = get_logger("typescript_generator")
        self.config = Config()
        self._indent_level = self.config.get("generator.indent_level", 4)

    def generate(self, workflow: Workflow) -> str:
        self.logger.info(f"Generating TypeScript code for workflow: {workflow.function}")
        try:
            code = [
                "// Generated by JSONFlow TypeScriptGenerator",
                "import Web3 from 'web3';",
                "",
                "interface Context { [key: string]: any; }",
                f"// Workflow: {workflow.function}",
                f"export async function {workflow.function}(): Promise<Context> {{",
                "    const context: Context = {};"
            ]
            inputs = workflow.schema.get('inputs', {})
            for key, spec in inputs.items():
                if not isinstance(spec, dict):
                    self.logger.warning(f"Invalid input spec for {key}")
                    continue
                default = spec.get('default')
                if default is None:
                    type_map = {
                        "string": "''",
                        "integer": "0",
                        "number": "0.0",
                        "boolean": "false",
                        "object": "{}",
                        "array": "[]",
                        "null": "null"
                    }
                    default = type_map.get(spec.get('type', 'null'), 'null')
                else:
                    default = self._format_value(default, spec.get('type', 'null'))
                code.append(f"    context['{key}'] = {default};")
            for step in workflow.steps:
                code.append(self.generate_step(step, indent=1))
            code.append("    return context;")
            code.append("}")
            code.extend([
                "",
                "// Simulated helper functions",
                "async function simulateAiInfer(model: string, input: any): Promise<any> { return { result: 'simulated' }; }",
                "async function simulateWorkflow(id: string, args: any): Promise<any> { return { result: 'simulated' }; }"
            ])
            return "\n".join(filter(None, code))
        except Exception as e:
            self.logger.error(f"TypeScript code generation failed: {str(e)}")
            raise ValueError(f"TypeScript code generation failed: {str(e)}")

    def generate_step(self, step: Dict[str, Any], indent: int) -> str:
        step_type = step.get('type')
        handlers = {
            'set': self.generate_set,
            'if': self.generate_if,
            'return': self.generate_return,
            'try': self.generate_try,
            'while': self.generate_while,
            'foreach': self.generate_foreach,
            'assert': self.generate_assert,
            'ai_infer': self.generate_ai_infer,
            'blockchain_operation': self.generate_blockchain_operation,
            'call_workflow': self.generate_call_workflow
        }
        handler = handlers.get(step_type)
        if handler:
            code = handler(step)
        elif step_type.startswith('custom_'):
            code = self.generate_custom(step)
        else:
            code = f"// Unsupported step type: {step_type}"
        if step.get('ui'):
            code = f"{code}\n    // UI: {json.dumps(step['ui'])}"
        return self._indent_code(code, indent)

    def generate_blockchain_operation(self, step: Dict[str, Any]) -> str:
        chain = step.get('chain')
        action = step.get('action')
        params = step.get('params', {})
        target = step.get('target')
        if chain == "ethereum" and action == "transfer":
            to_address = params.get('to')
            value = params.get('value')
            if not to_address or not re.match(r'^0x[a-fA-F0-9]{40}$', to_address):
                raise ValueError(f"Invalid Ethereum address: {to_address}")
            if not value or not isinstance(value, (int, str, float)):
                raise ValueError(f"Invalid value for transfer: {value}")
            sender = "context['sender'] ?? '0x0000000000000000000000000000000000000000'"
            return f"context['{target}'] = await (new Web3()).eth.sendTransaction({{ from: {sender}, to: '{to_address}', value: {value} }});"
        return f"// Unsupported blockchain operation: {chain} {action}"

    def generate_if(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        then_code = "\n".join(self.generate_step(s, indent=2) for s in step['then'])
        else_code = "\n".join(self.generate_step(s, indent=2) for s in step.get('else', []))
        code = [f"if ({condition}) {{", then_code, "}}"]
        if else_code:
            code.append("else {")
            code.append(else_code)
            code.append("}")
        return "\n".join(code)

    def generate_set(self, step: Dict[str, Any]) -> str:
        target = step.get('target')
        if not isinstance(target, str) or not target:
            raise ValueError("Invalid or missing target in set step")
        value = self._safe_format_expr(step['value'])
        return f"context['{target}'] = {value};"

    def generate_return(self, step: Dict[str, Any]) -> str:
        value = self._safe_format_expr(step['value'])
        return f"return {value};"

    def generate_try(self, step: Dict[str, Any]) -> str:
        body_code = "\n".join(self.generate_step(s, indent=2) for s in step['body'])
        catch = step.get('catch', {})
        catch_code = "\n".join(self.generate_step(s, indent=2) for s in catch.get('body', [])) if catch else ""
        finally_code = "\n".join(self.generate_step(s, indent=2) for s in step.get('finally', []))
        code = ["try {", body_code, "}"]
        if catch_code:
            error_var = catch.get('error_var', 'error')
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', error_var):
                raise ValueError(f"Invalid error variable name: {error_var}")
            code.append(f"catch ({error_var}: any) {{")
            code.append(f"    context['{error_var}'] = {error_var}.message;")
            code.append(catch_code)
            code.append("}")
        if finally_code:
            code.append("finally {")
            code.append(finally_code)
            code.append("}")
        return "\n".join(code)

    def generate_while(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        body_code = "\n".join(self.generate_step(s, indent=2) for s in step['body'])
        return f"while ({condition}) {{\n{body_code}\n}}"

    def generate_foreach(self, step: Dict[str, Any]) -> str:
        collection = self._safe_format_expr(step['collection'])
        iterator = step['iterator']
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', iterator):
            raise ValueError(f"Invalid iterator name: {iterator}")
        body_code = "\n".join(self.generate_step(s, indent=2) for s in step['body'])
        return f"for (const {iterator} of {collection}) {{\n    context['{iterator}'] = {iterator};\n{body_code}\n}}"

    def generate_assert(self, step: Dict[str, Any]) -> str:
        condition = self._safe_format_expr(step['condition'])
        message = step.get('message', 'Assertion failed')
        if not isinstance(message, str):
            raise ValueError("Assert message must be a string")
        return f"if (!({condition})) {{ throw new Error(\"{message}\"); }}"

    def generate_ai_infer(self, step: Dict[str, Any]) -> str:
        model = step.get('model')
        input_data = self._safe_format_expr(step['input'])
        target = step.get('target')
        if not model or not target:
            raise ValueError("Missing model or target in ai_infer step")
        return f"context['{target}'] = await simulateAiInfer('{model}', {input_data});"

    def generate_call_workflow(self, step: Dict[str, Any]) -> str:
        workflow_id = step.get('workflow')
        target = step.get('target')
        if not workflow_id or not target:
            raise ValueError("Missing workflow or target in call_workflow step")
        args = ", ".join(f"{k}: {self._safe_format_expr(v)}" for k, v in step.get('args', {}).items())
        return f"context['{target}'] = await simulateWorkflow('{workflow_id}', {{ {args} }});"

    def generate_custom(self, step: Dict[str, Any]) -> str:
        custom_type = step.get('type')
        props = step.get('custom_properties', {})
        return f"// Custom step: {custom_type} with properties {json.dumps(props)}"

    def _safe_format_expr(self, expr: Any) -> str:
        formatted = self._format_expr(expr)
        formatted = re.sub(
            r"context\.get\(['\"](.*?)['\"]\)",
            r"context[\1] ?? null",
            formatted
        )
        return formatted

    def _format_expr(self, expr: Any) -> str:
        if not isinstance(expr, dict):
            return json.dumps(expr)
        if 'get' in expr:
            return f"context['{expr['get']}'] ?? null"
        if 'value' in expr:
            return json.dumps(expr['value'])
        if 'add' in expr:
            return f"({' + '.join(self._format_expr(e) for e in expr['add'])})"
        if 'subtract' in expr:
            return f"({' - '.join(self._format_expr(e) for e in expr['subtract'])})"
        if 'multiply' in expr:
            return f"({' * '.join(self._format_expr(e) for e in expr['multiply'])})"
        if 'divide' in expr:
            return f"({' / '.join(self._format_expr(e) for e in expr['divide'])})"
        if 'compare' in expr:
            return f"({self._format_expr(expr['compare']['left'])} {expr['compare']['op']} {self._format_expr(expr['compare']['right'])})"
        if 'not' in expr:
            return f"!({self._format_expr(expr['not'])})"
        if 'and' in expr:
            return f"({' && '.join(self._format_expr(e) for e in expr['and'])})"
        if 'or' in expr:
            return f"({' || '.join(self._format_expr(e) for e in expr['or'])})"
        if 'concat' in expr:
            return f"({' + '.join(self._format_expr(e) for e in expr['concat'])})"
        raise ValueError(f"Unsupported expression: {expr}")

    def _format_value(self, value: Any, json_type: str) -> str:
        if json_type == "string":
            return f"'{value}'" if isinstance(value, str) else "''"
        elif json_type == "integer":
            return str(value) if isinstance(value, int) else "0"
        elif json_type == "number":
            return str(value) if isinstance(value, (int, float)) else "0.0"
        elif json_type == "boolean":
            return str(value).lower() if isinstance(value, bool) else "false"
        elif json_type == "object":
            return "{}"
        elif json_type == "array":
            return "[]"
        return "null"

    def _indent_code(self, code: str, indent: int) -> str:
        indent_str = " " * (indent * self._indent_level)
        return "\n".join(indent_str + line for line in code.split("\n") if line.strip())

def register_typescript_generator():
    from engine.generator import register_generator
    register_generator('typescript', TypeScriptGenerator)